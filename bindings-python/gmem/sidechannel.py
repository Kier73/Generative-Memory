"""
gmem.sidechannel — Sidechannel Detection (Varietal Fingerprinting).

Detects whether a data stream was generated by a known seed/context
by computing cosine similarity against reference fingerprints.

Mathematics:
    Similarity(S, T) = (S · T) / (||S|| · ||T||)
    If similarity > threshold → manifold authorship confirmed.

Use cases:
    - Verify a received data block was produced by a specific seed
    - Detect if a stream matches a known variety signature
    - Authentication without revealing the seed
"""

import math
from gmem.hashing import MASK64


class SidechannelDetector:
    """
    Algebraic Resonance Detector.

    Detects whether a raw data stream matches a known variety signature
    using fuzzy cosine resonance.
    """

    __slots__ = ('_references', 'threshold', 'last_confidence',
                 'last_locked_signature')

    def __init__(self, threshold: float = 0.95):
        """
        Args:
            threshold: Similarity threshold for positive lock (0.0 to 1.0).
        """
        self._references: dict[int, list[float]] = {}
        self.threshold = threshold
        self.last_confidence = 0.0
        self.last_locked_signature = None

    def generate_reference(self, ctx, sample_size: int = 64) -> list[float]:
        """
        Generate a reference fingerprint from a context.

        Fetches `sample_size` values from address 0 onward and stores
        them as the reference for this seed.
        """
        ref = [ctx.fetch(i) for i in range(sample_size)]
        self._references[ctx.seed] = ref
        return ref

    def register_reference(self, seed: int, reference: list[float]):
        """Register a pre-computed reference fingerprint for a seed."""
        self._references[seed] = reference

    def probe_block(self, block: list[float]) -> int | None:
        """
        Test a data block against all registered references.

        Args:
            block: A list of float values to test.

        Returns:
            The seed of the matched reference, or None if no match.
        """
        if not block or len(block) < 2:
            return None

        best_seed = None
        best_similarity = -1.0

        for seed, ref in self._references.items():
            # Use the shorter of the two for comparison
            n = min(len(block), len(ref))
            sim = _cosine_similarity(block[:n], ref[:n])

            if sim > best_similarity:
                best_similarity = sim
                best_seed = seed

        self.last_confidence = best_similarity

        if best_similarity >= self.threshold:
            self.last_locked_signature = best_seed
            return best_seed

        self.last_locked_signature = None
        return None

    def verify_authorship(self, ctx, block: list[float]) -> bool:
        """
        Verify that a specific context produced the given block.

        If no reference exists for this seed, one is auto-generated.
        """
        if ctx.seed not in self._references:
            self.generate_reference(ctx, max(len(block), 64))

        result = self.probe_block(block)
        return result == ctx.seed


def _cosine_similarity(a: list[float], b: list[float]) -> float:
    """
    Cosine similarity between two vectors.

    sim(A, B) = (A · B) / (||A|| · ||B||)
    """
    dot = sum(x * y for x, y in zip(a, b))
    norm_a = math.sqrt(sum(x * x for x in a))
    norm_b = math.sqrt(sum(y * y for y in b))
    if norm_a == 0 or norm_b == 0:
        return 0.0
    return dot / (norm_a * norm_b)


def cosine_similarity(a: list[float], b: list[float]) -> float:
    """Public cosine similarity function."""
    return _cosine_similarity(a, b)
